# 步骤2：目标形状适配——方案与任务清单

## 目标
- 在不同终端、窗口尺寸、方向变化下，确保目标形状（originalShape）始终以归一化点集为唯一数据源，按当前画布尺寸和 scale 还原为实际像素点，保证形状始终居中、无变形、无错位。
- 适配逻辑需支持任意画布尺寸、极端宽高比、动态切换，杜绝历史错位、拉伸、丢失等问题。

## 设计原则
1. **归一化存储，像素级还原**：originalShape 仅存储归一化点（0~1 或标准尺寸），适配时根据当前画布尺寸和 scale 还原为像素点。
2. **全局唯一数据源**：所有目标形状渲染、拼图切割、吸附判定等均以 GameContext.state.originalShape 为唯一来源，禁止多源同步。
3. **幂等适配，自动驱动**：每次画布尺寸/方向变化后自动适配，无需手动触发，保证多次切换后形状始终居中、无变形。
4. **像素级居中与对齐**：适配后目标形状在画布内始终居中，边界安全区一致，避免偏移。
5. **详细注释与文档**：所有适配流程、参数、假设条件需补充注释，便于团队理解和维护。

---

## 核心流程与数据结构

### 1. 数据结构
- **originalShape: Point[]**
  - 归一化点集，通常以标准尺寸（如1000x1000）或0~1区间存储。
  - 仅存储形状本身的结构信息，不包含像素坐标。
- **GameContext.state.canvasWidth/canvasHeight/scale/orientation**
  - 当前画布像素尺寸与缩放信息，由 step1 适配流程集中管理。

### 2. 适配流程
1. 监听画布尺寸/方向变化（由 step1 驱动）。
2. 读取 originalShape 的归一化点集。
3. 计算当前画布的有效绘制区域（考虑安全区、scale、边距等）。
4. 按照归一化点集和当前画布尺寸，将每个点还原为实际像素坐标：
   - 若以标准尺寸（如1000x1000）存储，则：
     - scale = min(canvasWidth / 1000, canvasHeight / 1000) * shapeScaleFactor
     - 偏移 offsetX/offsetY = 使形状居中
     - 还原点：x = (point.x - 500) * scale + canvasWidth/2，y = (point.y - 500) * scale + canvasHeight/2
   - 若以0~1区间存储，则：
     - x = point.x * canvasWidth
     - y = point.y * canvasHeight
5. 生成适配后的像素点集，供渲染与后续拼图切割使用。
6. 适配流程需幂等，支持多次切换、极端尺寸。

---

## 分步执行与验证任务

| 步骤 | 任务内容 | 预期结果 | 验证方式 |
|------|----------|----------|----------|
| 2.1  | 归一化存储 originalShape 点集 | 形状点集仅以标准尺寸或0~1区间存储，无像素依赖 | 代码审查/单元测试 |
| 2.2  | 监听画布尺寸/方向变化，触发适配 | 每次尺寸/方向变化均能自动触发适配流程 | 自动化测试/日志验证 |
| 2.3  | 计算 scale、偏移量，生成像素点集 | 适配后形状始终居中、无变形 | 自动化测试/可视化对比 |
| 2.4  | 多端/极端尺寸下适配幂等性 | 多次切换尺寸/方向，形状无错位、无拉伸 | 自动化+手动多轮切换 |
| 2.5  | 安全区/边距处理 | 形状始终在画布安全区内，无溢出 | 自动化测试/边界场景 |
| 2.6  | 异常兜底与回退 | 异常数据或极端尺寸下形状不消失 | 自动化+手动极端场景 |

- 每步建议配套单元测试、自动化E2E脚本和手动可视化验证，确保每个子任务独立可追踪、可回归。

---

## 适配算法与实现要点

- **标准尺寸归一化**：推荐所有 originalShape 以标准尺寸（如1000x1000）归一化存储，便于跨端、跨尺寸适配。
- **scale 因子**：适配时统一用 min(canvasWidth/1000, canvasHeight/1000) 计算缩放，保证形状不变形。
- **像素级居中**：适配后形状中心点与画布中心重合，偏移量 offsetX/offsetY 精确计算。
- **安全区处理**：如有安全区/边距，需在适配时扣除，防止形状溢出。
- **幂等性**：多次切换尺寸/方向，形状始终居中、无错位。
- **异常兜底**：如 originalShape 数据异常或画布尺寸极端，需兜底回退，防止渲染异常。

---

## 自动化与手动验证 checklist

| 步骤 | 适配内容 | 自动化验证 | 手动验证 |
|------|----------|------------|----------|
| 2    | 目标形状 | 切换尺寸/方向后形状始终居中、无变形 | 多次切换无错位、无拉伸 |

- 自动化测试建议：
  - resize/orientationchange 后，断言目标形状中心点与画布中心重合，所有点均在画布安全区内。
  - 多端/多方向/极端尺寸下，形状无变形、无错位。
- 手动测试建议：
  - 多次切换窗口尺寸、横竖屏，观察目标形状始终居中、无拉伸、无错位。

---

## 历史问题防范点
- 禁止假设 originalShape 为像素点，必须以归一化点集为唯一数据源。
- 适配逻辑不得遗漏 scale、偏移量等关键参数，防止形状变形或偏移。
- 画布尺寸极端时，需兜底回退，防止形状溢出或消失。
- 适配流程需与 step1 保持解耦，仅依赖画布状态，不依赖拼图块等下游状态。

---

## 工程落地建议
1. **工具函数标准化**：抽象 shape 归一化与反归一化工具函数，便于后续拼图块适配复用。
2. **全局状态唯一性**：所有形状适配仅依赖 GameContext.state.originalShape 和画布状态，禁止多源同步。
3. **详细注释与文档**：关键流程、参数、假设条件需补充注释，便于团队理解和维护。
4. **自动化测试全覆盖**：为目标形状适配编写自动化测试脚本，覆盖常规、极端、边界场景。
5. **性能优化**：适配流程需高效，避免卡顿，可用 requestAnimationFrame、节流等手段优化批量重绘。

---

## 后续优化建议
- 持续补充自动化与手动测试用例，覆盖更多极端场景。
- 定期 review 适配流程与工具函数，优化性能与健壮性。
- 收集用户在不同设备/方向下的体验反馈，持续迭代适配策略。
- 如有新形状类型或特殊需求，优先以归一化存储与适配为准，保持方案一致性。

---

> 本方案为目标形状适配的工程落地指南，适用于本项目及后续类似响应式拼图/交互类产品的目标形状适配与优化。 