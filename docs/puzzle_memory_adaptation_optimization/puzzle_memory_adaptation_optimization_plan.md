# 拼图记忆机制适配优化落地方案

## 一、方案目标与设计原则

- **目标**：确保在浏览器窗口大小、方向、设备变化时，画布与拼图所有核心状态（位置、尺寸、角度、交互进度等）均能被“记忆”并按比例适配，保证游戏体验不中断，拼图块不会丢失或错位。
- **原则**：
  1. **全局唯一数据源**：所有状态集中在 GameContext，避免多源同步。
  2. **归一化存储 + 适配还原**：所有与画布相关的参数均以归一化（相对画布/目标形状）方式存储，适配时还原为实际像素。
  3. **分层分步适配**：画布 → 目标形状 → 拼图块（未散开/已散开/已完成）分层分步适配，保证每一层都能独立、准确响应变化。
  4. **交互状态持久化**：拼图块的旋转、拖拽、吸附等交互状态也需归一化存储，适配后能恢复。
  5. **分步验证**：每步适配后均有自动化/手动验证，确保无丢失、错位、闪烁。

---

## 二、现状与问题分析（仅供参考，严禁复用历史缺陷）

> **注意：本节内容仅为历史参考，所有列出的问题和缺陷，均为新方案必须彻底规避和优化的对象。新机制的设计与实现以本方案为唯一标准，严禁复用或迁移历史缺陷。**

### 1. 当前实现的机制

1. **状态集中管理**  
   所有拼图块状态、原始目标点位、画布尺寸等均集中存储在 `GameContext`，实现单一数据源。
2. **画布尺寸变化的记忆与适配**  
   画布尺寸变化时，`updateCanvasSize` 会记录当前尺寸为 `previousCanvasSize`，新尺寸写入 `canvasWidth/canvasHeight`。
   `usePuzzleAdaptation` 监听尺寸变化，自动计算所有拼图块在新画布下的正确位置和旋转，实现状态的“记忆”与“恢复”。
3. **适配逻辑**  
   - 已完成块：查找 originalPositions，按归一化点位和新尺寸缩放恢复。
   - 未完成块：以当前中心点归一化（相对于旧尺寸），再反归一化到新尺寸，保持相对位置。
4. **批量状态更新**  
   适配后通过 `UPDATE_ADAPTED_PUZZLE_STATE` action 批量更新 puzzle 状态和 previousCanvasSize。

### 2. 存在的问题

1. **action payload 字段不一致**  
   `usePuzzleAdaptation` dispatch 的 payload 字段为 `puzzle`，而 reducer 期望 `newPuzzleData`，导致适配结果无法正确写入 state。
2. **originalPositions 归一化假设未强制保证**  
   已完成块的适配假设 originalPositions 的点为归一化坐标，若生成逻辑未保证，适配会有偏差。
3. **未完成块的 normalizedX/Y 未持久化**  
   适配时每次临时计算 normalizedX/Y，未在拖拽/移动时同步写入 state，导致多次适配可能出现误差累积。
4. **注释不够完善**  
   关键流程、数据结构、适配假设等注释不够详细，影响后续维护和协作。

### 3. 待完善内容

1. **修正 action payload 字段一致性**  
   统一 `UPDATE_ADAPTED_PUZZLE_STATE` 的 payload 字段名，确保适配结果能正确写入 state。
2. **保证 originalPositions 归一化**  
   明确 originalPositions 生成时为归一化点位，或适配逻辑根据实际点位类型调整缩放方式。
3. **持久化 normalizedX/Y 字段**  
   在拼图块拖拽、移动等操作后，同步更新 normalizedX/Y 字段，提升适配精度。
4. **补充详细注释和文档**  
   对关键数据结构、适配流程、假设条件等补充注释，便于团队理解和维护。

---

## 三、分层分步适配与验证流程（新方案主线）

### 步骤 1：全局画布适配
- **内容**：监听窗口/方向变化，更新 canvasWidth/canvasHeight/scale/orientation。
- **存储**：GameContext.state.canvas（或 canvasWidth/canvasHeight/scale/orientation）。
- **适配**：记录 previousCanvasSize，驱动下层适配。
- **验证**：
  - 自动化：resize/orientationchange 后，画布尺寸与设备/容器一致。
  - 手动：不同设备/方向下画布无拉伸、无留白。
- **历史问题防范点**：
  - 必须保证每次适配前后 previousCanvasSize 与当前尺寸同步，杜绝因字段不一致导致的适配失效。

### 步骤 2：目标形状适配
- **内容**：读取 originalShape 的归一化点，用新画布尺寸和 scale 还原为实际像素点。
- **存储**：GameContext.state.originalShape（归一化点）。
- **适配**：保证形状始终居中/对齐。
- **验证**：
  - 自动化：切换尺寸/方向后，目标形状始终居中、无变形。
  - 手动：多次切换后形状无错位。
- **历史问题防范点**：
  - 明确 originalShape 始终为归一化点，适配逻辑不得假设为绝对像素。

### 步骤 3：切割后未散开的拼图适配
- **内容**：读取每块的 normalizedX/Y，用新画布尺寸还原为实际像素坐标，rotation 保持。
- **存储**：GameContext.state.puzzle（含 normalizedX/Y/rotation）。
- **适配**：归一化坐标 × 新画布尺寸，rotation 保持。
- **验证**：
  - 自动化：resize/orientationchange 后，所有拼图块位置与切割初始状态一致。
  - 手动：切割后多次切换尺寸/方向，拼图块无丢失、无重叠。
- **历史问题防范点**：
  - 拖拽/移动拼图块时，必须实时同步 normalizedX/Y，杜绝多次适配误差累积。

### 步骤 4：散开拼图适配
- **内容**：读取每块的归一化随机坐标和角度，用新画布尺寸还原为实际像素坐标，rotation 保持。
- **存储**：GameContext.state.puzzle（归一化坐标和角度）。
- **适配**：同上，归一化坐标 × 新画布尺寸，rotation 保持。
- **验证**：
  - 自动化：散开后多次切换尺寸/方向，拼图块分布合理、无重叠、无丢失。
  - 手动：极端尺寸/方向下拼图块始终可见。
- **历史问题防范点**：
  - 散开逻辑必须保证归一化坐标落在画布安全区域，防止拼图块丢失。

### 步骤 5：拼图交互状态与完成形状适配
- **内容**：拼图块的旋转、拖拽、吸附、完成等交互状态归一化存储，适配后自动恢复。
- **存储**：GameContext.state.puzzle（交互计数器、吸附/完成状态、归一化坐标）。
- **适配**：坐标/角度适配，计数器/状态直接保留。
- **验证**：
  - 自动化：交互后切换尺寸/方向，拼图块状态（旋转、吸附、完成）无丢失。
  - 手动：完成形状始终与目标形状重合。
- **历史问题防范点**：
  - 交互状态与归一化参数必须同步更新，防止状态丢失或错乱。

---

## 四、能效提升与工程落地建议

1. **批量适配与批量更新**
   - 画布尺寸/方向变化时，统一触发 usePuzzleAdaptation，分层适配所有内容，通过批量 action 一次性更新所有状态，避免多次重绘。
2. **归一化参数实时同步**
   - 每次拼图块交互（拖拽、旋转、吸附等）后，实时同步归一化参数到 state，提升适配精度。
3. **适配工具函数标准化**
   - 提供归一化与反归一化的通用方法，便于各层调用，减少重复代码。
4. **自动化测试全覆盖**
   - 针对每一步适配，编写自动化测试脚本，覆盖常规、极端、边界场景。
5. **性能监控与优化**
   - 适配流程需高效，避免卡顿。可用 requestAnimationFrame、节流等手段优化批量重绘。
6. **异常与历史兼容处理**
   - 如遇历史数据无归一化参数，首次适配时自动补齐归一化字段。
   - 如适配后拼图块超出画布边界，自动回退到安全区域。

---

## 五、分步落地与验证 checklist

| 步骤 | 适配内容 | 自动化验证 | 手动验证 |
|------|----------|------------|----------|
| 1    | 画布适配 | resize/orientationchange 后画布尺寸正确 | 多端/多方向下无拉伸/留白 |
| 2    | 目标形状 | 切换尺寸/方向后形状居中 | 多次切换无错位 |
| 3    | 未散开拼图 | 切割后多次切换尺寸/方向拼图块无丢失 | 无重叠/错位 |
| 4    | 散开拼图 | 散开后多次切换拼图块分布合理 | 极端尺寸下可见 |
| 5    | 交互/完成 | 交互后切换拼图状态无丢失 | 完成形状与目标重合 |

---

## 六、后续建议与持续优化

- **补充详细注释与文档**：每个参数、适配流程、假设条件均需文档化，便于团队理解和维护。
- **持续自动化测试**：每次适配优化后，回归全流程自动化测试。
- **性能与体验监控**：定期分析适配流程性能，优化重绘与状态同步。
- **用户反馈收集**：收集真实用户在不同设备/方向下的体验，持续迭代适配策略。

---

> 本方案为拼图记忆机制适配优化的工程落地指南，适用于本项目及后续类似响应式拼图/交互类产品的适配与优化。 