<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>形状适配测试</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }

        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .test-section {
            background: white;
            margin: 20px 0;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .test-canvas {
            border: 2px solid #333;
            background: #fff;
            margin: 10px 0;
        }

        .controls {
            margin: 10px 0;
        }

        .controls button {
            margin: 5px;
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }

        .controls button:hover {
            background: #0056b3;
        }

        .info {
            background: #e9ecef;
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
            font-family: monospace;
            font-size: 12px;
        }

        .status {
            color: #28a745;
            font-weight: bold;
        }

        .error {
            color: #dc3545;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div class="test-container">
        <h1>形状适配测试页面</h1>
        <p>此页面用于测试目标形状在不同画布尺寸下的适配效果</p>

        <div class="test-section">
            <h2>测试1：基础形状适配</h2>
            <div class="controls">
                <button onclick="generateTestShape()">生成测试形状</button>
                <button onclick="resizeCanvas(400, 400)">400x400</button>
                <button onclick="resizeCanvas(600, 400)">600x400</button>
                <button onclick="resizeCanvas(800, 600)">800x600</button>
                <button onclick="resizeCanvas(300, 500)">300x500 (竖屏)</button>
                <button onclick="resizeCanvas(500, 300)">500x300 (横屏)</button>
            </div>
            <canvas id="testCanvas" class="test-canvas" width="400" height="400"></canvas>
            <div id="canvasInfo" class="info">画布尺寸: 400x400</div>
        </div>

        <div class="test-section">
            <h2>测试2：适配算法验证</h2>
            <div class="controls">
                <button onclick="testAdaptationAlgorithm()">测试适配算法</button>
                <button onclick="testMultipleAdaptations()">测试多次适配</button>
                <button onclick="testExtremeRatios()">测试极端比例</button>
            </div>
            <div id="algorithmResults" class="info">点击按钮开始测试...</div>
        </div>

        <div class="test-section">
            <h2>测试3：边界情况处理</h2>
            <div class="controls">
                <button onclick="testEmptyShape()">测试空形状</button>
                <button onclick="testInvalidSize()">测试无效尺寸</button>
                <button onclick="testZeroSize()">测试零尺寸</button>
            </div>
            <div id="boundaryResults" class="info">点击按钮开始测试...</div>
        </div>
    </div>

    <script>
        // 模拟形状适配算法
        function adaptShape(originalShape, oldSize, newSize) {
            if (!originalShape || originalShape.length === 0) return originalShape;
            if (!oldSize || !newSize) return originalShape;
            if (oldSize.width <= 0 || oldSize.height <= 0) return originalShape;
            if (newSize.width <= 0 || newSize.height <= 0) return originalShape;

            try {
                // 计算缩放比例 - 使用统一缩放保持形状不变形
                const scaleX = newSize.width / oldSize.width;
                const scaleY = newSize.height / oldSize.height;
                const scale = Math.min(scaleX, scaleY); // 使用较小的缩放比例避免变形

                // 计算新旧画布的中心点
                const oldCenterX = oldSize.width / 2;
                const oldCenterY = oldSize.height / 2;
                const newCenterX = newSize.width / 2;
                const newCenterY = newSize.height / 2;

                // 适配所有形状点
                return originalShape.map(point => {
                    // 计算点相对于旧中心的位置
                    const relativeX = point.x - oldCenterX;
                    const relativeY = point.y - oldCenterY;

                    // 应用缩放并重新定位到新中心
                    return {
                        ...point,
                        x: newCenterX + relativeX * scale,
                        y: newCenterY + relativeY * scale,
                    };
                });
            } catch (error) {
                console.error('形状适配失败:', error);
                return originalShape; // 返回原始形状作为兜底
            }
        }

        // 生成测试形状
        function generateTestShape() {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');

            // 清空画布
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 生成一个简单的多边形
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = Math.min(canvas.width, canvas.height) * 0.3;

            window.currentShape = [];
            const sides = 6;
            for (let i = 0; i < sides; i++) {
                const angle = (i / sides) * 2 * Math.PI;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);
                window.currentShape.push({ x, y });
            }

            drawShape(ctx, window.currentShape);
            updateCanvasInfo();
        }

        // 绘制形状
        function drawShape(ctx, shape) {
            if (!shape || shape.length === 0) return;

            ctx.beginPath();
            ctx.moveTo(shape[0].x, shape[0].y);
            for (let i = 1; i < shape.length; i++) {
                ctx.lineTo(shape[i].x, shape[i].y);
            }
            ctx.closePath();

            // 绘制填充
            ctx.fillStyle = 'rgba(0, 123, 255, 0.3)';
            ctx.fill();

            // 绘制边框
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // 绘制中心点
            const centerX = shape.reduce((sum, p) => sum + p.x, 0) / shape.length;
            const centerY = shape.reduce((sum, p) => sum + p.y, 0) / shape.length;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
            ctx.fillStyle = '#dc3545';
            ctx.fill();
        }

        // 调整画布尺寸
        function resizeCanvas(width, height) {
            const canvas = document.getElementById('testCanvas');
            const ctx = canvas.getContext('2d');

            if (!window.currentShape) {
                alert('请先生成测试形状');
                return;
            }

            // 记录旧尺寸
            const oldSize = { width: canvas.width, height: canvas.height };

            // 设置新尺寸
            canvas.width = width;
            canvas.height = height;
            const newSize = { width, height };

            // 适配形状
            window.currentShape = adaptShape(window.currentShape, oldSize, newSize);

            // 重新绘制
            ctx.clearRect(0, 0, width, height);
            drawShape(ctx, window.currentShape);

            updateCanvasInfo();
        }

        // 更新画布信息
        function updateCanvasInfo() {
            const canvas = document.getElementById('testCanvas');
            const info = document.getElementById('canvasInfo');

            let shapeInfo = '';
            if (window.currentShape && window.currentShape.length > 0) {
                const centerX = window.currentShape.reduce((sum, p) => sum + p.x, 0) / window.currentShape.length;
                const centerY = window.currentShape.reduce((sum, p) => sum + p.y, 0) / window.currentShape.length;
                shapeInfo = `, 形状中心: (${centerX.toFixed(1)}, ${centerY.toFixed(1)})`;
            }

            info.innerHTML = `画布尺寸: ${canvas.width}x${canvas.height}${shapeInfo}`;
        }

        // 测试适配算法
        function testAdaptationAlgorithm() {
            const results = document.getElementById('algorithmResults');
            let output = '<h4>适配算法测试结果:</h4>';

            // 测试用例
            const testCases = [
                {
                    name: '正方形到长方形',
                    oldSize: { width: 400, height: 400 },
                    newSize: { width: 600, height: 400 }
                },
                {
                    name: '长方形到正方形',
                    oldSize: { width: 600, height: 400 },
                    newSize: { width: 400, height: 400 }
                },
                {
                    name: '横屏到竖屏',
                    oldSize: { width: 800, height: 600 },
                    newSize: { width: 600, height: 800 }
                }
            ];

            // 创建测试形状
            const testShape = [
                { x: 200, y: 150 },
                { x: 250, y: 200 },
                { x: 200, y: 250 },
                { x: 150, y: 200 }
            ];

            testCases.forEach(testCase => {
                const adaptedShape = adaptShape(testShape, testCase.oldSize, testCase.newSize);
                const originalCenter = {
                    x: testShape.reduce((sum, p) => sum + p.x, 0) / testShape.length,
                    y: testShape.reduce((sum, p) => sum + p.y, 0) / testShape.length
                };
                const adaptedCenter = {
                    x: adaptedShape.reduce((sum, p) => sum + p.x, 0) / adaptedShape.length,
                    y: adaptedShape.reduce((sum, p) => sum + p.y, 0) / adaptedShape.length
                };

                const expectedCenterX = testCase.newSize.width / 2;
                const expectedCenterY = testCase.newSize.height / 2;
                const centerError = Math.sqrt(
                    Math.pow(adaptedCenter.x - expectedCenterX, 2) +
                    Math.pow(adaptedCenter.y - expectedCenterY, 2)
                );

                const status = centerError < 1 ? 'PASS' : 'FAIL';
                const statusClass = status === 'PASS' ? 'status' : 'error';

                output += `<div><strong>${testCase.name}:</strong> <span class="${statusClass}">${status}</span><br>`;
                output += `原始中心: (${originalCenter.x.toFixed(1)}, ${originalCenter.y.toFixed(1)})<br>`;
                output += `适配中心: (${adaptedCenter.x.toFixed(1)}, ${adaptedCenter.y.toFixed(1)})<br>`;
                output += `期望中心: (${expectedCenterX}, ${expectedCenterY})<br>`;
                output += `中心误差: ${centerError.toFixed(2)}px</div><br>`;
            });

            results.innerHTML = output;
        }

        // 测试多次适配
        function testMultipleAdaptations() {
            const results = document.getElementById('algorithmResults');
            let output = '<h4>多次适配测试结果:</h4>';

            // 创建测试形状
            let shape = [
                { x: 200, y: 150 },
                { x: 250, y: 200 },
                { x: 200, y: 250 },
                { x: 150, y: 200 }
            ];

            const originalShape = JSON.parse(JSON.stringify(shape));
            let currentSize = { width: 400, height: 400 };

            // 进行多次适配
            const adaptations = [
                { width: 600, height: 400 },
                { width: 800, height: 600 },
                { width: 300, height: 500 },
                { width: 400, height: 400 } // 回到原始尺寸
            ];

            adaptations.forEach((newSize, index) => {
                shape = adaptShape(shape, currentSize, newSize);
                currentSize = newSize;

                const center = {
                    x: shape.reduce((sum, p) => sum + p.x, 0) / shape.length,
                    y: shape.reduce((sum, p) => sum + p.y, 0) / shape.length
                };

                output += `<div>适配 ${index + 1}: ${newSize.width}x${newSize.height}, 中心: (${center.x.toFixed(1)}, ${center.y.toFixed(1)})</div>`;
            });

            // 检查最终形状是否接近原始形状（在相同尺寸下）
            const finalCenter = {
                x: shape.reduce((sum, p) => sum + p.x, 0) / shape.length,
                y: shape.reduce((sum, p) => sum + p.y, 0) / shape.length
            };
            const originalCenter = {
                x: originalShape.reduce((sum, p) => sum + p.x, 0) / originalShape.length,
                y: originalShape.reduce((sum, p) => sum + p.y, 0) / originalShape.length
            };

            const centerDrift = Math.sqrt(
                Math.pow(finalCenter.x - originalCenter.x, 2) +
                Math.pow(finalCenter.y - originalCenter.y, 2)
            );

            const status = centerDrift < 5 ? 'PASS' : 'FAIL';
            const statusClass = status === 'PASS' ? 'status' : 'error';

            output += `<br><div><strong>多次适配稳定性:</strong> <span class="${statusClass}">${status}</span><br>`;
            output += `中心漂移: ${centerDrift.toFixed(2)}px (阈值: 5px)</div>`;

            results.innerHTML = output;
        }

        // 测试极端比例
        function testExtremeRatios() {
            const results = document.getElementById('algorithmResults');
            let output = '<h4>极端比例测试结果:</h4>';

            const testShape = [
                { x: 200, y: 200 },
                { x: 300, y: 200 },
                { x: 300, y: 300 },
                { x: 200, y: 300 }
            ];

            const extremeCases = [
                { name: '超宽屏', oldSize: { width: 400, height: 400 }, newSize: { width: 1200, height: 300 } },
                { name: '超窄屏', oldSize: { width: 400, height: 400 }, newSize: { width: 200, height: 800 } },
                { name: '极小尺寸', oldSize: { width: 400, height: 400 }, newSize: { width: 100, height: 100 } },
                { name: '极大尺寸', oldSize: { width: 400, height: 400 }, newSize: { width: 2000, height: 1500 } }
            ];

            extremeCases.forEach(testCase => {
                const adaptedShape = adaptShape(testShape, testCase.oldSize, testCase.newSize);

                // 检查形状是否在画布边界内
                const minX = Math.min(...adaptedShape.map(p => p.x));
                const maxX = Math.max(...adaptedShape.map(p => p.x));
                const minY = Math.min(...adaptedShape.map(p => p.y));
                const maxY = Math.max(...adaptedShape.map(p => p.y));

                const inBounds = minX >= 0 && maxX <= testCase.newSize.width &&
                    minY >= 0 && maxY <= testCase.newSize.height;

                const status = inBounds ? 'PASS' : 'FAIL';
                const statusClass = status === 'PASS' ? 'status' : 'error';

                output += `<div><strong>${testCase.name}:</strong> <span class="${statusClass}">${status}</span><br>`;
                output += `边界: X(${minX.toFixed(1)}, ${maxX.toFixed(1)}), Y(${minY.toFixed(1)}, ${maxY.toFixed(1)})<br>`;
                output += `画布: ${testCase.newSize.width}x${testCase.newSize.height}</div><br>`;
            });

            results.innerHTML = output;
        }

        // 测试边界情况
        function testEmptyShape() {
            const results = document.getElementById('boundaryResults');
            const emptyShape = [];
            const result = adaptShape(emptyShape, { width: 400, height: 400 }, { width: 600, height: 400 });

            const status = Array.isArray(result) && result.length === 0 ? 'PASS' : 'FAIL';
            const statusClass = status === 'PASS' ? 'status' : 'error';

            results.innerHTML = `<strong>空形状测试:</strong> <span class="${statusClass}">${status}</span><br>返回结果: ${JSON.stringify(result)}`;
        }

        function testInvalidSize() {
            const results = document.getElementById('boundaryResults');
            const testShape = [{ x: 100, y: 100 }, { x: 200, y: 200 }];
            const result = adaptShape(testShape, null, { width: 600, height: 400 });

            const status = JSON.stringify(result) === JSON.stringify(testShape) ? 'PASS' : 'FAIL';
            const statusClass = status === 'PASS' ? 'status' : 'error';

            results.innerHTML = `<strong>无效尺寸测试:</strong> <span class="${statusClass}">${status}</span><br>应返回原始形状`;
        }

        function testZeroSize() {
            const results = document.getElementById('boundaryResults');
            const testShape = [{ x: 100, y: 100 }, { x: 200, y: 200 }];
            const result = adaptShape(testShape, { width: 0, height: 400 }, { width: 600, height: 400 });

            const status = JSON.stringify(result) === JSON.stringify(testShape) ? 'PASS' : 'FAIL';
            const statusClass = status === 'PASS' ? 'status' : 'error';

            results.innerHTML = `<strong>零尺寸测试:</strong> <span class="${statusClass}">${status}</span><br>应返回原始形状`;
        }

        // 页面加载完成后自动生成测试形状
        window.addEventListener('load', function () {
            generateTestShape();
        });
    </script>
</body>

</html>